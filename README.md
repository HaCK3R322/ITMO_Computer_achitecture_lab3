# ITMO_Computer_achitecture_lab3
Translator + Proccessor

# Forth. Транслятор и модель

- Андросов Иван Сергеевич P33111.
- `forth | stack | harv | hw | tick | struct | stream | port | prob1`


## Язык программирования

``` ebnf
<program> ::= <statement>*
<statement> ::= <variable-declaration> | <conditional-statement> | <loop-statement> | <arithmetic-operation> | <stack-operation> | <io-operation> | <number>
<variable-declaration> ::= "VARIABLE" <identifier>
<conditional-statement> ::= "IF" <statement>* "THEN"
<loop-statement> ::= "BEGIN" <statement>* "UNTIL"
<arithmetic-operation> ::= "+" | "-" | "/" | "*" | "%" | "<" | ">" | "="
<stack-operation> ::= "@" | "!" | "SWAP" | "DROP" | "DUP" | "OVER"
<io-operation> ::= "." | "ACCEPT"
<identifier> ::= <letter> <letter-or-digit>*
<number> ::= <digit>+

<letter> ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
<digit> ::= "0" | "1" | ... | "9"
<letter-or-digit> ::= <letter> | <digit>
```

Язык стек-ориентированный. Поддерживает следующие операции:
- `<число>` -- запушить какое-то число
- `VARIABLE <имя>` -- задекларировать переменную, используя имя которой можно получить адрес выделенной ячейки.
  Т.е. написав `variable some_var` мы зарезервируем ячейку, а написав `some_var` мы пушим в стек адрес этой ячейки с которым уже делаем че хотим.
- `+ - / * %` -- классические арифметические операции. Забираем два верхних значения из стека и возвращаем результат операции (`10 2 /` превратится в `5`).
- `> < =` -- сравнение чисел. В результате забираем оба числа и пушим результат: `-1` если ПРАВДА  и `0` если ЛОЖЬ.
- `IF <statement> THEN` -- забираем число с вершины стека и, если оно не равно `0`, то выполняем весь код вплоть до соответствующего `THEN`. Вложенность поддерживается.
- `BEGIN <statement> UNTIL` -- выполняем стейтмент после бегина, если по результатам на вершине лежит `0` (забирается с вершины), то выполняем ещё раз.
- `SWAP` -- меняем местами верхние два числа стека
- `DUP` -- дублируем число на вершине стека
- `DROP` -- извлекаем число с вершины стека
- `OVER` -- запихиваем на вершину числор лежащее на вершине стека минус 1. (`1 2 3 dup` => `1 2 3 2`)
- `!` -- пишем по адресу (вершина стека) значение (вершина стека минус 1). Оба числа извлекаются.
- `@` -- пушим в стек число лежащее по адресу соответствующему вершине стека. Адрес забирается, число пушится.
- `.` -- подать вершину стека на вывод. как обычно, вершина стека извлекается.
- `ACCEPT` -- с ввода записываем в память символ за символом до тех пор, пока не прочитаем `0` (его тоже пишем). Затем на вершине стека будет лежать адрес первой ячейки, с которой начали писать.
Сразу аллоцирует 128 ячеек под строку.


## Организация памяти

Память разделена на память для команд и память для данных.

Память команд адресуется номером команды.
- Реализуется списком словарей, описывающих инструкции (одно слово -- одна ячейка).

Память данных адресуется 12 битным линейным адресным пространством начиная с `0x000` и заканчивая `0xFFF`.
- Машинное слово - 32 бита, знаковое.
- Реализуется списком чисел.

Особенность языка:
- стек начинается с адреса `0x000` и растет вниз (`0x000, 0x001, ...`)
- переменные и константы располагаются начиная с адреса `0x800` и ниже.

## Система команд

Особенности процессора:

- Машинное слово -- 16 бит, беззнаковое.
- В зависимости от типа команды, биты 0...11 являются адресом
- Память данных:
    - имеет свой регистр адреса `ad`
    - может быть записана по установленому адресному регистру с выхода `ALU` или порта ввода
    - может быть прочитана по установленному адресному регистру на правый вход `ALU` или на порт ввывода
    - `ad` может быть установлен либо с выхода `ALU`, либо с адресного регистра `декодера`
- Регистр аккумулятора: `acc`:
    - может использоваться как левый вход `ALU`
    - может быть записан с выхода `ALU`
- Регистр указателя стека: `sp`:
    - может быть подан на правый вход `ALU`
    - может быть записан с выхода `ALU`
    - 12 бит
- Ввод-вывод -- порты ввода/вывода, токенизирован, символьный
- `pc` -- счётчик команд:
    - инкрементируется после каждой инструкции и может быть сложен с адресным регистром декодера если открыт соответствующий вентиль
- `decoder` -- имеет два регистра:
    - `address` -- адресный регистр, который устанавливается для некоторых команд по результату декодирования инструкции
    - `instruction` -- регистр, содержащий код инструкции, который используется контрольным юнитом `CU` 

### Набор инструкций

| Syntax | Mnemonic     | Кол-во тактов | Comment                          |
|:-------|:-------------|---------------|:---------------------------------|
|        | PUSH `<addr>`| 5             | запушить в стек значение ячейки по адресу `<addr>`|
| `!`    | SET          | 7             | см. язык                         |
| `@`    | GET          | 5             | см. язык                         |
|        | CMP          | 4             | вычесть из левого вход `ALU` правый вход. Используется для установления флагов|
|        | JMP `<addr>` | 1             | безусловный переход. открыть вентиль, из-за чего на следующем цикле выборки инструкции произойдет сложение указателя адреса и `<addr>`                         |
|        | JZ `<addr>`  | 1             | аналогично JMP, только вентиль открывается если установлен ZF                       |
|        | JNZ `<addr>` | 1             | аналогично с JZ, но в случае если ZF == 0              |
|        | JL `<addr>`  | 1             | аналогично с JZ, но в случае если NF == 1 |
| `+`    | ADD          | 7             | см. язык                       |
| `-`    | SUB          | 7             | см. язык                        |
| `%`    | MOD          | 7             | см. язык                        |
| `/`    | DIV          | 7             | см. язык                        |
| `*`    | MUL          | 7             | см. язык                        |
| `SWAP` | SWAP         | 12            | см. язык                        |
| `OVER` | OVER         | 7             | см. язык                        |
| `DUP`  | DUP          | 7             | см. язык                        |
| `DROP` | DROP         | 1             | см. язык                        |
| `.`    | PRINT        | 3             | выводит число с вершины стека на порт вывода                        |
|        | READ         | 3             | записывает с порта ввода в ячейку лежащую по адресу находящемуся на вершине стека                        |


### Кодирование инструкций

- Машинный код сериализуется в список JSON.
- Один элемент списка, одна инструкция.
- Индекс списка -- адрес инструкции. Используется для команд перехода.

Пример:

```json
[
    {
        "opcode": "PUSH",
        "address": 0x800,
        "related_token_index": 1
    }
]
```

где:

- `opcode` -- строка с кодом операции;
- `address` -- адрес, может отсутствовать;
- `related_token_index` -- индекс токена, в результате парсинга которого была добавленна эта инструкция.

## Транслятор

Интерфейс командной строки: `translator.py <input_file> <target_file>"`

Реализовано в модуле: [translator](./translator.py)

Этапы трансляции (функция `translate`):

1. Трансформирование текста в последовательность значимых токенов.
2. Пре-преверка на неправильные последовательности конструкций языка (IF--THEN, BEGIN--UNTIL), вывод предупреждений (возможное деление на 0).
3. Генерация машинного кода.

Правила генерации машинного кода:

- для команд, однозначно соответствующих инструкциям -- прямое отображение;
- для команд, вызывающих добавление числа на вершину стека -- добавление в память ячейки с этим числом и добавление в список команд инструкции `PUSH` с соответствуюшим адресом. (если включена оптимизация, то перед добавлением будет произведен поиск по константам и, в случае нахождения идентичного значения - новой ячейки в памяти не появится, инструкция использует адрес константы)
- для декларации переменной -- проверка имени на допустимость (запрещено передекларирование, цифровое имя переменной, отсутствие имени, пересечение с символами языка)
- для ветвлений -- проверка парности. С входом в точку ветвления идёт запоминание количества добавленных инструкций, после чего добавленные инструкции окружаются соответствующими инструкциями ветвления.
- для циклов -- проверка парности. С входом в цикл аналогично ветлвениям запоминается количество добавленных инструкций, после чего добавляются инструкции ветвления.

## Модель процессора

Реализовано в модуле: [machine](./machine.py).

### DataPath

``` text

       +--------------+  addr    +--------+
-----> |      ad      |--------->|  data  |
       +--------------+          | memory |
                                 |        |
                                 |        |                     |
                                 |        |    data_out         |
                                 |        |---------------------+-------> data_out 
                                 |        |
                                 |        |
                                 +--------+











                            latch
                              |
                              v
                     +--------------+  addr   +--------+
               +---->| data_address |---+---->|  data  |
               |     +--------------+   |     | memory |
           +-------+                    |     |        |
    sel -->|  MUX  |         +----------+     |        |
           +-------+         |                |        |
            ^     ^          |                |        |
            |     |          |        data_in |        | data_out
            |     +---(+1)---+          +---->|        |-----+
            |                |          |     |        |     |
            +---------(-1)---+          |  oe |        |     |
                                        | --->|        |     |
                                        |     |        |     |
                                        |  wr |        |     |
                                        | --->|        |     |
                                        |     +--------+     |
                                        |                    v
                                    +--------+     latch  +-----+
                          sel ----> |  MUX   |    ------->| acc |
                                    +--------+            +-----+
                                     ^   ^  ^                |
                                     |   |  |                +---(==0)---> zero
                                     |   |  |                |
                                     |   |  +---(+1)---------+
                                     |   |                   |
                                     |   +------(-1)---------+
                                     |                       |
            input -------------------+                       +---------> output
```

Реализован в классе `DataPath`.

- `data_memory` -- однопортовая, поэтому либо читаем, либо пишем.
- `input` -- вызовет остановку процесса моделирования, если буфер входных значений закончился.

Сигналы (обрабатываются за один такт, реализованы в виде методов класса):

- `latch_data_addr` -- защёлкнуть выбранное значение в `data_addr`;
- `latch_acc` -- защёлкнуть в аккумулятор выход памяти данных;
- `output` -- записать аккумулятор в порт вывода (обработка на python);
- `wr` -- записать выбранное значение в память:
    - инкрементированное;
    - декрементированное;
    - с порта ввода (обработка на python).

Флаги:

- `zero` -- отражает наличие нулевого значения в аккумуляторе.

### RAM

``` text
   +------------------(+1)-------+
   |                             |
   |   +-----+                   |
   +-->|     |     +---------+   |    +---------+
       | MUX |---->| program |---+--->| program |
   +-->|     |     | counter |        | memory  |
   |   +-----+     +---------+        +---------+
   |      ^                               |
   |      | sel_next                      | current instruction
   |      |                               |
   +---------------(select-arg)-----------+
          |                               |      +---------+
          |                               |      |  step   |
          |                               |  +---| counter |
          |                               |  |   +---------+
          |                               v  v        ^
          |                       +-------------+     |
          +-----------------------| instruction |-----+
                      +---------->| decoder     |
                      |           +-------------+
                      |                   |
                      |                   | signals
                      |                   v
                      |    zero     +----------+
                      +-------------|          |
                                    | DataPath |
                     input -------->|          |----------> output
                                    +----------+
```

Реализован в классе `ControlUnit`.

- Hardwired (реализовано полностью на python).
- Моделирование на уровне инструкций.
- Трансляция инструкции в последовательность (0-2 такта) сигналов: `decode_and_execute_instruction`.
- `step_counter` необходим для многотактовых команд:
    - в классе `ControlUnit` отсутствует, т.к. моделирование производится на уровне инструкций.

Сигнал:

- `latch_program_counter` -- сигнал для обновления счётчика команд в ControlUnit.

Особенности работы модели:

- Для журнала состояний процессора используется стандартный модуль logging.
- Количество инструкций для моделирования ограничено hardcoded константой.
- Остановка моделирования осуществляется при помощи исключений:
    - `EOFError` -- если нет данных для чтения из порта ввода-вывода;
    - `StopIteration` -- если выполнена инструкция `halt`.
- Управление симуляцией реализовано в функции `simulate`.

## Апробация

В качестве тестов использовано два алгоритма:

1. [hello world](examples/hello.bf).
2. [cat](examples/cat.bf) -- программа `cat`, повторяем ввод на выводе.

Интеграционные тесты реализованы тут: [integration_test](./integration_test.py) в двух вариантах:

- через golden tests, конфигурация которых лежит в папке [golden](./golden) (рекомендуемый способ).
- через unittest (устаревший пример).

CI:

``` yaml
lab3-example:
  stage: test
  image:
    name: python-tools
    entrypoint: [""]
  script:
    - cd src/brainfuck
    - python3-coverage run -m pytest --verbose
    - find . -type f -name "*.py" | xargs -t python3-coverage report
    - find . -type f -name "*.py" | xargs -t pep8 --ignore=E501
    - find . -type f -name "*.py" | xargs -t pylint
```

где:

- `python3-coverage` -- формирование отчёта об уровне покрытия исходного кода.
- `pytest` -- утилита для запуска тестов.
- `pep8` -- утилита для проверки форматирования кода. `E501` (длина строк) отключено, но не следует этим злоупотреблять.
- `pylint` -- утилита для проверки качества кода. Некоторые правила отключены в отдельных модулях с целью упрощения кода.
- Docker image `python-tools` включает в себя все перечисленные утилиты. Его конфигурация: [Dockerfile](./Dockerfile).

Пример использования и журнал работы процессора на примере `cat`:

``` console
> cd src/brainfuck
> cat examples/foo_input.txt
foo
> cat examples/cat.bf 
,[.,]
> ./translator.py examples/cat.bf target.out
source LoC: 1 code instr: 6
> cat target.out 
[
    {
        "opcode": "input",
        "term": [
            1,
            1,
            ","
        ]
    },
    {
        "opcode": "jz",
        "arg": 5,
        "term": [
            1,
            2,
            "["
        ]
    },
    {
        "opcode": "print",
        "term": [
            1,
            3,
            "."
        ]
    },
    {
        "opcode": "input",
        "term": [
            1,
            4,
            ","
        ]
    },
    {
        "opcode": "jmp",
        "arg": 1,
        "term": [
            1,
            5,
            "]"
        ]
    },
    {
        "opcode": "halt"
    }
]
> ./machine.py target.out examples/foo_input.txt
DEBUG:root:{TICK: 0, PC: 0, ADDR: 0, OUT: 0, ACC: 0} input  (',' @ 1:1)
DEBUG:root:input: 'f'
DEBUG:root:{TICK: 2, PC: 1, ADDR: 0, OUT: 102, ACC: 0} jz 5 ('[' @ 1:2)
DEBUG:root:{TICK: 4, PC: 2, ADDR: 0, OUT: 102, ACC: 102} print  ('.' @ 1:3)
DEBUG:root:output: '' << 'f'
DEBUG:root:{TICK: 6, PC: 3, ADDR: 0, OUT: 102, ACC: 102} input  (',' @ 1:4)
DEBUG:root:input: 'o'
DEBUG:root:{TICK: 8, PC: 4, ADDR: 0, OUT: 111, ACC: 102} jmp 1 (']' @ 1:5)
DEBUG:root:{TICK: 9, PC: 1, ADDR: 0, OUT: 111, ACC: 102} jz 5 ('[' @ 1:2)
DEBUG:root:{TICK: 11, PC: 2, ADDR: 0, OUT: 111, ACC: 111} print  ('.' @ 1:3)
DEBUG:root:output: 'f' << 'o'
DEBUG:root:{TICK: 13, PC: 3, ADDR: 0, OUT: 111, ACC: 111} input  (',' @ 1:4)
DEBUG:root:input: 'o'
DEBUG:root:{TICK: 15, PC: 4, ADDR: 0, OUT: 111, ACC: 111} jmp 1 (']' @ 1:5)
DEBUG:root:{TICK: 16, PC: 1, ADDR: 0, OUT: 111, ACC: 111} jz 5 ('[' @ 1:2)
DEBUG:root:{TICK: 18, PC: 2, ADDR: 0, OUT: 111, ACC: 111} print  ('.' @ 1:3)
DEBUG:root:output: 'fo' << 'o'
DEBUG:root:{TICK: 20, PC: 3, ADDR: 0, OUT: 111, ACC: 111} input  (',' @ 1:4)
DEBUG:root:input: '\n'
DEBUG:root:{TICK: 22, PC: 4, ADDR: 0, OUT: 10, ACC: 111} jmp 1 (']' @ 1:5)
DEBUG:root:{TICK: 23, PC: 1, ADDR: 0, OUT: 10, ACC: 111} jz 5 ('[' @ 1:2)
DEBUG:root:{TICK: 25, PC: 2, ADDR: 0, OUT: 10, ACC: 10} print  ('.' @ 1:3)
DEBUG:root:output: 'foo' << '\n'
DEBUG:root:{TICK: 27, PC: 3, ADDR: 0, OUT: 10, ACC: 10} input  (',' @ 1:4)
WARNING:root:Input buffer is empty!
INFO:root:output_buffer: 'foo\n'
foo

instr_counter:  15 ticks: 28
```

| ФИО           | алг.  | LoC       | code байт | code инстр. | инстр. | такт. | вариант |
|---------------|-------|-----------|-----------|-------------|--------|-------|---------|
| Преподавателя | hello | ...       | -         | ...         | ...    | ...   | ...     |
| Преподавателя | cat   | 1         | -         | 6           | 15     | 28    | ...     |


<program> ::= <statement>*
<statement> ::= <variable-declaration> | <conditional-statement> | <loop-statement> | <arithmetic-operation> | <stack-operation> | <io-operation> | <number>
<variable-declaration> ::= "VARIABLE" <identifier>
<conditional-statement> ::= "IF" <statement>* "THEN"
<loop-statement> ::= "BEGIN" <statement>* "UNTIL"
<arithmetic-operation> ::= "+" | "-" | "/" | "*" | "%" | "<" | ">" | "="
<stack-operation> ::= "@" | "!" | "SWAP" | "SET" | "DUP" | "OVER" | "DROP"
<io-operation> ::= "." | "ACCEPT"
<identifier> ::= <letter> <letter-or-digit>*
<number> ::= <digit>+

<letter> ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
<digit> ::= "0" | "1" | ... | "9"
<letter-or-digit> ::= <letter> | <digit>
